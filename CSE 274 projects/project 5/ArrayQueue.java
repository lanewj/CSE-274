/* * A class that implements the ADT queue by using an expandable circular array * with one unused location after the back of the queue. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.1 */public final class ArrayQueue<T> implements QueueInterface<T> {	private T[] queue; // Circular array of queue entries and one unused						// location	private int frontIndex; // Index of front entry	private int backIndex; // Index of back entry	private int size;	private static final int DEFAULT_CAPACITY = 3;	private static final int MAX_CAPACITY = 10000;	public ArrayQueue() {		this(DEFAULT_CAPACITY);	}	public ArrayQueue(int initialCapacity) {		checkCapacity(initialCapacity);		// The cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] tempQueue = (T[]) new Object[initialCapacity + 1];		queue = tempQueue;		frontIndex = 0;		backIndex = -1;		size = 0;	} // end constructor	public void enqueue(T newEntry) 	{		//System.out.println(newEntry);		ensureCapacity();		backIndex = (backIndex + 1) % queue.length;		queue[backIndex] = newEntry;		size++;				//System.out.println(this.toString());		//System.out.println(size);		//ensureCapacity();			} // end enqueue	public T getFront() {		if (isEmpty())			throw new EmptyQueueException();		else			return queue[frontIndex];	} // end getFront	public T dequeue() {		if (isEmpty())			throw new EmptyQueueException();		else {			T data = queue[frontIndex];			queue[frontIndex] = null;			frontIndex = (frontIndex + 1) % queue.length;			size--;			// STUB			return data;		} // end if	} // end dequeue	public boolean isEmpty() {		return size == 0;	} // end isEmpty	public void clear() {		if (!isEmpty()) { // deallocates only the used portion			for (int index = frontIndex; index != backIndex; index = (index + 1) % queue.length) {				queue[index] = null;			}			queue[backIndex] = null;		}		System.out.println(this.toString());		frontIndex = 0;		backIndex = queue.length - 1;		size =0;	} // end clear		// Throws an exception if this object is not initialized.	private void checkInitialization() {// To Do:		if(queue==null)		{			throw new IllegalStateException(					"the queue has not been initalized");					}	} // end checkInitialization	// Throws an exception if the client requests a capacity that is too large.	private void checkCapacity(int capacity) {		if (capacity > MAX_CAPACITY)			throw new IllegalStateException(					"Attempt to create a queue " + "whose capacity exceeds " + "allowed maximum.");	}	// Doubles the size of the array queue if it is full.	private void ensureCapacity() {		/*		 * if (frontIndex == ((backIndex + 2) % queue.length)) // If array is		 * full, { T[] oldQueue = queue; int oldSize = oldQueue.length; int		 * newSize = 2 * oldSize; checkCapacity(newSize - 1); // Queue capacity		 * is 1 fewer than array // length		 * 		 * // The cast is safe because the new array contains null entries		 * 		 * T[] tempQueue = (T[]) new Object[newSize]; queue = tempQueue;		 * 		 * // Number of queue entries = oldSize - 1; index of last entry = //		 * oldSize - 2 for (int index = 0; index < oldSize - 1; index++) {		 * queue[index] = oldQueue[frontIndex]; System.out.println("queue[" +		 * index + "] = " + oldQueue[frontIndex]); // ***TESTING frontIndex =		 * (frontIndex + 1) % oldSize; } // end for		 * 		 * frontIndex = 0; backIndex = oldSize - 2;		 * System.out.println("End ensureCapacity(): newSize = " + newSize); //		 * ***TESTING		 */				if (size == queue.length) {						T[] larger = (T[]) (new Object[queue.length * 2]);			for (int scan = 0; scan < size; scan++) {				larger[scan] = queue[frontIndex];				frontIndex = (frontIndex + 1) % queue.length;			}			frontIndex = 0;			backIndex = size-1;			queue = larger;		}		// end if	}	public String toString() {		String result = "";		int scan = 0;		while (scan < size) {			if (queue[scan] != null) {				result += queue[scan].toString() + "\n";			}			scan++;		}		return result;// end ensureCapacity	}}